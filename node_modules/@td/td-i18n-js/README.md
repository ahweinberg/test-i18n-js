# td-i18n-js
**td-i18n-js** is a typescript library which is responsible for managing the **user-visible content** on the browser side of the applications across the whole Teladoc ecosystem. It uses [i18n](https://github.com/fnando/i18n) library as a basis and adds support for specific translations for **brand**, **country**, **app** and lazy-loading of translations.

The **I18n** class in this library can be used to get the translations for a dictionary on-demand (i.e. when a translation for a key from a dictionary is requested) from an endpoint in the server mounted with **teladoc_cms** engine. The translations are stored in `window.sessionStorage` for an hour. After that they are removed and need to be fetched again. The whole process is explained in the [Storing translations](#storing-translations) section. In order to fetch the translations, `brand`, `country`, `app` and `locale` should be present. `brand`, `country`, `app` are saved in both `window.localStorage` and `window.sessionStorage`, `locale` is a property of the class that needs to be set additionally (its default value is the value of the `defaultLocale` property which by default is set to `"en"`). `loading_from_redis` is another metadata which is used to tell whether **TeladocCMS** used **Redis** as a translations source or not (it is saved in `window.localStorage`). On each creation of an instance of the **I18n** class, `brand`, `country`, `app` and `loading_from_redis` should be passed. If what value is passed is different from what is already saved in `sesionStorage` (or `localStorage` if they are not yet saved in `sessionStorage`) for any of them, all saved translations are removed.

The **I18n** class can be used to get translations from dependencies outside Teladoc as well (e.g ruby gems like `activesupport`) and save them in `window.sessionStorage`. They can be fetched from another endpoint in the server mounted with **teladoc_cms** engine. This is done only if `nonTeladocTranslationsHash` is present (not empty string) when creating an instance of **I18n** class. `nonTeladocTranslationsHash` needs to be an md5 hash of the translations object which will be returned. This hash is used as a query parameter when making the request to the server. If it doesn't change, cached response will be returned.

The **I18n** class extends the **I18n** class in [i18n](https://github.com/fnando/i18n) library which means it has the same internationalization methods. In addition to them, the translations that will be searched for in the respective method are fetched and stored.

All requests to fetch translations are **synchronous**.

## Content
1. [Configuration](#configuration)
    - [Integration in JavaScript (React and CoffeeScript) that is used in the browser of Rails apps](#integration-in-javascript-react-and-coffeescript-that-is-used-in-the-browser-of-rails-apps)
    - [Integration in JavaScript (React and CoffeeScript) which is not used in the browser of Rails apps](#integration-in-javascript-react-and-coffeescript-which-is-not-used-in-the-browser-of-rails-apps)
2. [Storing translations](#storing-translations)
    - [Storing non-Teladoc translations](#storing-non-teladoc-translations)
    - [Storing a dictionary](#storing-a-dictionary)
    - [Invalidating translations](#invalidating-translations)
2. [Build](#build)
3. [Tests](#tests)
4. [Lint](#lint)
5. [## Publish changes into artifactory](#publish-changes-into-artifactory)

## Configuration
### Integration in JavaScript (React and CoffeeScript) that is used in the browser of Rails apps
You need to follow these steps:
- `yarn add @td/td-i18n-js@<version>` to add the library as a dependency and use an npm package from artifactory (or `yarn add git+ssh://git@github.com:Teladoc/td-i18n-js.git` if you want to link with git instead).
- `yarn install` to install it. After that, if you want to update it, run `yarn upgrade @td/td-i18n-js`.
- Make sure that you have access to the `index.js` asset in `dist\browser` folder which will be in `node_modules/@td/td-i18n-js`. This can be done by:
  - copying the asset under `public/assets` using `CopyWebpackPlugin`, if `webpack` is already configured. In this case `yarn build` needs to be run as well because it will call webpack. 
  - adding `node_modules` to `Rails.application.config.assets.paths` (in `config/initializers/assets.rb`).
- If the app already uses `teladoc_cms` gem, `layouts/i18n_js_config` layout is included in the app's `application_helper.rb`. This layout:
  - attaches two variables to the `window` object which hold the url of the endpoints used for fetching translations:
    - `CMS_DICTIONARY_ENDPOINT_URL` - the url of the endpoint used for fetching a single dictionary.
      - You can set `CMS_API_HOST` env variable in the application to set the host url of the application which returns the translations for a dictionary. If it is not set, same origin will be used (i.e. request will be made to the same application).
    - `NON_TELADOC_TRANSLATIONS_ENDPOINT_URL` - the endpoint used for fetching translations coming from dependencies outside Teladoc. *This can be skipped if there are no such translations.*
  - initializes **I18n** class and attaches it to the `window` object.

  To do this, `i18n-js` library needs to be loaded already. You will need to add `javascript_include_tag(<path/to/asset>)` in `application_helper.rb` before `html_response.push(javascript_include_tag("/teladoc_cms/translations?id=#{ActiveSupport::Digest.hexdigest(TeladocCMS::I18n.metadata.to_s)}", skip_pipeline: true))`. Here `<path/to/asset>` is where `index.js` asset in library's `dist\browser` is located (copied into).

### Integration in JavaScript (React and CoffeeScript) which is not used in the browser of Rails apps
You need to follow these steps:
- `yarn add @td/td-i18n-js@<version>` to add the library as a dependency and use an npm package from artifactory (or `yarn add git+ssh://git@github.com:Teladoc/td-i18n-js.git` if you want to link with git instead).
- `yarn install` to install it. After that, if you want to update it, run `yarn upgrade @td/td-i18n-js`.
- To be able to internationalize texts in the javascript, you will need to create an instance of the **I18n** class:
```
import { I18n } from "i18n-js";
import translations from "./translations.json";

const i18n = new I18n(
  {
    app: <app_name>,
    brand: <brand_name>,
    country: <country_name>,
    loading_from_redis: <loading_from_redis>,
  }, 
  <nonTeladocTranslationsHash> // if there are translations from external dependencies
);
```
Then you will be able to use all methods coming from [i18n](https://github.com/fnando/i18n/blob/main/README.md) library.

## Storing translations
### Storing non-Teladoc translations
Non-Teladoc translations (i.e. translations from external dependencies) are saved in **session storage** under `window.sessionStorage.non_teladoc_translations`. They are fetched when creating an instance of **I18n** class.
The endpoint that is used to get them, is `window.NON_TELADOC_TRANSLATIONS_ENDPOINT_URL`.

### Storing a dictionary
Translations are saved in **session storage** under `window.sessionStorage.translations`. There are also timestamps saved in **session storage** under `window.sessionStorage.timestamps` that hold timestamps of the last time when translation for locale and dictionary was requested.
Translations are saved in the following format:
```
{
  "<locale_name>": {
    "<feature_name>": {
      <feature_nested_keys>
    }
  }
}
```
Timestamps are saved in the following format:
```
{
  "<locale_name>.<feature_name>": "<timestamp>"
}
```
Translations are also assigned to the `translations` property of the instances of **I18n** class. The internationalization methods search there for translations.
When calling one of the methods of the **I18n** class a method that stores the translations for a dictionary is called. Here is what it does:
1. Check in timestamps if a timestamp for this **locale** and **dictionary** is present.
    - If yes, this means that the endpoint to fetch dictionary has been already called and there is no need to call it again. Don't go over next steps.
2. There is no timestamp for this **locale** and **dictionary**. Call the dictionary endpoint with the *app*, *country* and *brand* saved in the storage on **I18n** class initialization and the current locale (`i18n.locale()`). The endpoint will return translations for the passed locale and for all fallback locales.
3. Check if there are timestamps saved in the storage for some of the fallback locales. If so, remove them.
4. For each locale, deep merge the translations returned from the dictionary endpoint with non-teladoc translations (if any). Translations from the dictionary endpoint are with higher priority.
5. Save the translations and timestamps when they were fetched (current time) in session storage. Assign the translations from session storage to the instance of **I18n** class. 

### Invalidating translations
On each initialization of an instance of **I18n** class, it is checked which translations in the storage are *outdated (fetched more than 1 hour ago)*. All timestamps in the store are checked to see which are earlier than one hour ago and the translations for these locales and features are removed from the storage.

## Build
Run `yarn build` to create the `index.js` asset in `dist\browser` which can be used in the browser.

## Tests
Run `yarn test` to run the tests under `tests` folder.

## Lint
Run:
- `yarn lint` to run the linter and show the errors without trying to fix them.
- `yarn lint:eslint:fix` to run the linter, fix the errors that can be fixed automatically and show the other ones.

## Publish changes into artifactory
First you need to run the linter and build the library.

After that, run:
- `yarn version --prerelease --preid=canary` to bump the canary version (in `package.json`) (e.g. from `1.2.0-canary.0` to `1.2.0-canary.1`) or `yarn version --new-version [new_version]` but you'll need to pass the new version as an argument
- `npm publish` to publish the package into artifactory