import { Dict } from 'i18n-js';
import merge from 'lodash/merge';
import get from 'lodash/get';
import set from 'lodash/set';
import fetch from 'sync-fetch';
import I18n from '../I18n';
import jsLogger, { ILogger } from "js-logger";

jsLogger.useDefaults();

const logger: ILogger = jsLogger.get("myLogger");
// const CMS_DICTIONARY_ENDPOINT_URL = "https://teladoc-prod.adobecqms.net";

function getNonTeladocDictionaryTranslations(
  i18n: I18n,
  feature: string,
): Dict {
  const currentLocale = i18n.locale;
  const fallbackLocales: string[] = i18n.locales.get(currentLocale) || [currentLocale];

  const nonTeladocTranslations = i18n.storage.nonTeladocTranslations();

  const nonTeladocDictionaryTranslations: Dict = {};
  fallbackLocales.forEach((fallbackLocale: string) => {
    set(
      nonTeladocDictionaryTranslations,
      [fallbackLocale, feature],
      get(nonTeladocTranslations, [fallbackLocale, feature]),
    );
  });
  return nonTeladocDictionaryTranslations;
}

function testFetch(
    i18n: I18n,
    feature: string,
): Dict | null {
  const params = {
    locale: i18n.locale,
    app: i18n.app(),
    feature,
    country: i18n.country(),
    brand: i18n.brand(),
  };
  const response = fetch(`https://teladoc-prod.adobecqms.net/api/teladoc-core/v1/download-dictionary-by-language.en-us_${params.country}.${params.app}.${params.brand}.mhd.json`, {
    method: 'GET',
  });
  console.log(response.json().content);
  return response.ok ? response.json().content : null;

}

// function fetchDictionary(
//   i18n: I18n,
//   feature: string,
// ): Dict | null {
//   logger.info("fetching dictionary in storeDictionary.ts")
//   const params = {
//     locale: i18n.locale,
//     app: i18n.app(),
//     feature,
//     country: i18n.country(),
//     brand: i18n.brand(),
//   };
//
//   const response = fetch(`${window.CMS_DICTIONARY_ENDPOINT_URL}?${new URLSearchParams(params)}`, {
//     method: 'GET',
//   });
//
//   // console.log("response: " + response);
//   // logger.info("in storeDictionary.ts; response: $(response)")
//
//   return response.ok ? response.json() : null;
// }

function getTimestampsToStore(translations: Dict, feature: string): Dict {
  const locales = Object.keys(translations);
  const timestampKeys = locales.map((locale) => [locale, feature].join('.'));
  const currentTime = Date.now().toString();

  const timestamps: Dict = {};
  timestampKeys.forEach(
    (timestampKey) => { timestamps[timestampKey] = currentTime; },
  );

  return timestamps;
}

function addDictionaryToStore(
  i18n: I18n,
  translations: Dict,
  timestamps: Dict | null,
) {
  logger.info("add dictionary to store in storeDictionary.ts")
  // Remove existing translations for some locales if present
  i18n.removeTranslationsForTimestampKeys(timestamps?.keys || []);
  i18n.storage.removeTimestampsForTimestampKeys(timestamps?.keys || []);

  i18n.storage.storeTranslations(translations);
  if (timestamps !== null) {
    i18n.storage.storeTimestamps(timestamps);
  }
}

export default function storeDictionary(i18n: I18n, feature: string) {
  // Check if dictionary name is in storage timestamps and don't make requests if it's there
  if (`${i18n.locale}.${feature}` in i18n.storage.timestamps()) {
    return;
  }

  const dictionaryResponse = testFetch(i18n, feature);
  let nonTeladocTranslations = {};

  if (i18n.hasNonTeladocTranslations) {
    nonTeladocTranslations = getNonTeladocDictionaryTranslations(
      i18n,
      feature,
    );
  }

  if (dictionaryResponse !== null) {
    addDictionaryToStore(
      i18n,
      merge(nonTeladocTranslations, dictionaryResponse),
      getTimestampsToStore(dictionaryResponse, feature),
    );
  } else {
    addDictionaryToStore(i18n, nonTeladocTranslations, null);
  }
}
