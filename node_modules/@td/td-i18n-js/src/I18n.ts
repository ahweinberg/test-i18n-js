/* eslint no-underscore-dangle: ["error", { "allow": ["_hasNonTeladocTranslations"] }] */

import {
  I18n as BaseI18n,
  Dict,
  I18nOptions,
  TranslateOptions,
  Scope,
  DateTime,
  Numeric,
  NumberToCurrencyOptions,
  NumberToPercentageOptions,
  NumberToHumanSizeOptions,
  NumberToHumanOptions,
  StrftimeOptions,
  ToSentenceOptions,
  TimeAgoInWordsOptions,
} from 'i18n-js';

import { Metadata } from './typing';

import fetchNonTeladocTranslations from './cms/fetchNonTeladocTranslations';
import storeDictionary from './cms/storeDictionary';
import invalidateTranslations from './cms/invalidateTranslations';
import Storage from './storage';

export default class I18n extends BaseI18n {
  public storage: Storage;

  private _hasNonTeladocTranslations: boolean;

  constructor(
    metadata: Metadata,
    nonTeladocTranslationsHash: string = '',
    translations: Dict = {},
    options: Partial<I18nOptions> = {},
  ) {
    super(translations, options);

    this.storage = new Storage();
    this.setMetadata(metadata);

    if (nonTeladocTranslationsHash !== '') {
      fetchNonTeladocTranslations(this, nonTeladocTranslationsHash);
      this._hasNonTeladocTranslations = true;
    } else {
      this._hasNonTeladocTranslations = false;
    }
    invalidateTranslations(this);

    this.translations = this.storage.translations();
  }

  public translate<T = string>(
    scope: Scope,
    options?: TranslateOptions,
  ): string | T {
    const feature = this.getFeatureFromScope(scope);
    this.storeDictionary(feature);

    return super.translate<T>(scope, options);
  }

  public pluralize(
    count: number,
    scope: Scope,
    options?: TranslateOptions,
  ): string {
    const feature = this.getFeatureFromScope(scope);
    this.storeDictionary(feature);

    return super.pluralize(count, scope, options);
  }

  public localize(
    type: string,
    value: string | number | Date | null | undefined,
    options?: Dict,
  ): string {
    if (type === 'number') {
      this.storeDictionary('number');
    }

    return super.localize(type, value, options);
  }

  public toTime(scope: Scope, input: DateTime): string {
    const feature = this.getFeatureFromScope(scope);
    this.storeDictionary(feature);

    return super.toTime(scope, input);
  }

  public numberToCurrency(
    input: Numeric,
    options: Partial<NumberToCurrencyOptions> = {},
  ): string {
    this.storeDictionary('number');

    return super.numberToCurrency(input, options);
  }

  public numberToPercentage(
    input: Numeric,
    options: Partial<NumberToPercentageOptions> = {},
  ): string {
    this.storeDictionary('number');

    return super.numberToPercentage(input, options);
  }

  public numberToHumanSize(
    input: Numeric,
    options: Partial<NumberToHumanSizeOptions> = {},
  ): string {
    this.storeDictionary('number');

    return super.numberToHumanSize(input, options);
  }

  public numberToHuman(
    input: Numeric,
    options: Partial<NumberToHumanOptions> = {},
  ): string {
    this.storeDictionary('number');

    return super.numberToHuman(input, options);
  }

  public strftime(
    date: Date,
    format: string,
    options: Partial<StrftimeOptions> = {},
  ): string {
    this.storeDictionary('date');
    this.storeDictionary('time');

    return super.strftime(date, format, options);
  }

  public toSentence(
    items: any[],
    options: Partial<ToSentenceOptions> = {},
  ): string {
    this.storeDictionary('support');

    return super.toSentence(items, options);
  }

  public timeAgoInWords(
    fromTime: DateTime,
    toTime: DateTime,
    options: TimeAgoInWordsOptions = {},
  ): string {
    const feature = this.getFeatureFromScope(options.scope || 'datetime.distance_in_words');
    this.storeDictionary(feature);

    return super.timeAgoInWords(fromTime, toTime, options);
  }

  public get(scope: Scope): any {
    const feature = this.getFeatureFromScope(scope);
    this.storeDictionary(feature);

    return super.get(scope);
  }

  private getFeatureFromScope(scope: Scope): string {
    let feature = '';

    // Deal with string scopes.
    if (scope instanceof String || typeof scope === 'string') {
      [feature] = (scope as string).split(this.defaultSeparator);
    }

    // Deal with the scope as an array.
    if (scope instanceof Array) {
      [feature] = (scope as string[]);
    }

    return feature;
  }

  public setMetadata(metadata: Metadata) {
    const valueChanged = this.storage.setMetadata(metadata);

    if (valueChanged) {
      this.storage.clearTranslations();
      this.translations = {};
    }
  }

  public loadingFromRedis(): boolean {
    return this.storage.loadingFromRedis() === 'true';
  }

  public app(): string {
    return this.storage.app() || '';
  }

  public country(): string {
    return this.storage.country() || '';
  }

  public brand(): string {
    return this.storage.brand() || '';
  }

  public get hasNonTeladocTranslations(): boolean {
    return this._hasNonTeladocTranslations;
  }

  public storeDictionary(feature: string) {
    storeDictionary(this, feature);

    this.translations = this.storage.translations();
  }

  public removeTranslationsForTimestampKeys(timestampKeys: string[]) {
    this.translations = this.storage.removeTranslationsForTimestampKeys(timestampKeys);
  }
}
