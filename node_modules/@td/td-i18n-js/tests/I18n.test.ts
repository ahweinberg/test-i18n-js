import I18n from '../src/I18n';
import {
  dictionaryEndpointParams, mockI18n, oldTimestamp, outdatedTimestamp,
} from '../src/setupTests';

const fetchMock = require('sync-fetch');

describe('I18n', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('initialization', () => {
    describe('check for difference with metadata in the storage', () => {
      describe('when having the same metadata in the storage', () => {
        const appName = 'app';
        const countryName = 'country';
        const brandName = 'brand';
        const loadingFromRedis = true;

        const metadata = {
          app: appName,
          country: countryName,
          brand: brandName,
          loading_from_redis: loadingFromRedis,
        };
        let i18n: I18n;

        const translations = {
          'en-us': {
            feature: {
              key1: 'New English value 1',
              key3: 'English value 3',
            },
          },
        };

        beforeEach(() => {
          window.sessionStorage.setItem('i18n:app', appName);
          window.sessionStorage.setItem('i18n:country', countryName);
          window.sessionStorage.setItem('i18n:brand', brandName);
          window.sessionStorage.setItem('i18n:loading_from_redis', loadingFromRedis.toString());
          window.sessionStorage.setItem('i18n:translations', JSON.stringify(translations));

          i18n = new I18n(metadata);
        });

        it('does not clear the translations in the storage and assign them to translations class property', () => {
          expect(i18n.app()).toBe(appName);
          expect(i18n.country()).toBe(countryName);
          expect(i18n.brand()).toBe(brandName);
          expect(i18n.loadingFromRedis()).toBe(loadingFromRedis);
          expect(i18n.hasNonTeladocTranslations).toBe(false);

          expect(i18n.translations).toEqual(translations);
        });
      });

      describe('when not having metadata in the storage', () => {
        const appName = 'app';
        const countryName = 'country';
        const brandName = 'brand';
        const loadingFromRedis = true;

        const metadata = {
          app: appName,
          country: countryName,
          brand: brandName,
          loading_from_redis: loadingFromRedis,
        };
        let i18n: I18n;

        const translations = {
          'en-us': {
            feature: {
              key1: 'New English value 1',
              key3: 'English value 3',
            },
          },
        };

        const timestamps = {
          'en-us.feature': Date.now(),
        };

        beforeEach(() => {
          window.sessionStorage.removeItem('i18n:app');
          window.sessionStorage.removeItem('i18n:country');
          window.sessionStorage.removeItem('i18n:brand');
          window.sessionStorage.removeItem('i18n:loading_from_redis');
          window.localStorage.removeItem('i18n:app');
          window.localStorage.removeItem('i18n:country');
          window.localStorage.removeItem('i18n:brand');
          window.sessionStorage.setItem('i18n:translations', JSON.stringify(translations));
          window.sessionStorage.setItem('i18n:timestamps', JSON.stringify(timestamps));

          i18n = new I18n(metadata);
        });

        it('clears the translations in the storage and assigns them to translations class property', () => {
          expect(i18n.app()).toBe(appName);
          expect(i18n.country()).toBe(countryName);
          expect(i18n.brand()).toBe(brandName);
          expect(i18n.loadingFromRedis()).toBe(loadingFromRedis);
          expect(i18n.hasNonTeladocTranslations).toBe(false);

          expect(i18n.storage.timestamps()).toEqual({});
          expect(i18n.storage.translations()).toEqual({});
          expect(i18n.translations).toEqual({});
        });
      });
    });

    describe('invalidate translations from the storage', () => {
      const appName = 'app';
      const countryName = 'country';
      const brandName = 'brand';
      const loadingFromRedis = true;

      const metadata = {
        app: appName,
        country: countryName,
        brand: brandName,
        loading_from_redis: loadingFromRedis,
      };
      let i18n: I18n;

      const translations = {
        'en-us': {
          otherFeature: {
            key1: 'English value 1',
          },
          feature: {
            key1: 'English value 1',
            key2: 'English value 2',
          },
        },
        'fr-ca': {
          feature: {
            key1: 'French value 1',
          },
        },
      };

      const timestamps = {
        'en-us.feature': Date.now(),
        'en-us.otherFeature': outdatedTimestamp(),
        'fr-ca.feature': outdatedTimestamp(),
      };

      const expectedTimestamps = {
        'en-us.feature': Date.now(),
      };

      const expectedTranslations = {
        'en-us': {
          feature: {
            key1: 'English value 1',
            key2: 'English value 2',
          },
        },
        'fr-ca': {},
      };

      beforeEach(() => {
        window.sessionStorage.setItem('i18n:app', appName);
        window.sessionStorage.setItem('i18n:country', countryName);
        window.sessionStorage.setItem('i18n:brand', brandName);
        window.sessionStorage.setItem('i18n:loading_from_redis', loadingFromRedis.toString());
        window.sessionStorage.setItem('i18n:translations', JSON.stringify(translations));
        window.sessionStorage.setItem('i18n:timestamps', JSON.stringify(timestamps));

        i18n = new I18n(metadata);
      });

      it('removes the outdated translations from the storage', () => {
        expect(i18n.app()).toBe(appName);
        expect(i18n.country()).toBe(countryName);
        expect(i18n.brand()).toBe(brandName);
        expect(i18n.loadingFromRedis()).toBe(loadingFromRedis);
        expect(i18n.hasNonTeladocTranslations).toBe(false);

        expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
        expect(i18n.storage.translations()).toEqual(expectedTranslations);
        expect(i18n.translations).toEqual(expectedTranslations);
      });
    });

    describe('when nonTeladocTranslationsHash is passed', () => {
      const appName = 'app';
      const countryName = 'country';
      const brandName = 'brand';
      const loadingFromRedis = true;

      const metadata = {
        app: appName,
        country: countryName,
        brand: brandName,
        loading_from_redis: loadingFromRedis,
      };
      const nonTeladocTranslationsHash = '1111111';
      const nonTeladocTranslations = {
        en: {
          date: {
            formats: {
              default: '%Y-%m-%d', short: '%b %d', long: '%B %d, %Y',
            },
            day_names: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            precision: 3,
            round_mode: 'default',
            significant: false,
            strip_insignificant_zeros: false,
          },
        },
      };
      let i18n: I18n;

      const translations = {
        'en-us': {
          otherFeature: {
            key1: 'English value 1',
          },
          feature: {
            key1: 'English value 1',
            key2: 'English value 2',
          },
        },
        'fr-ca': {
          feature: {
            key1: 'French value 1',
          },
        },
      };

      const timestamps = {
        'en-us.feature': Date.now(),
        'en-us.otherFeature': outdatedTimestamp(),
        'fr-ca.feature': outdatedTimestamp(),
      };

      const expectedTimestamps = {
        'en-us.feature': Date.now(),
      };

      const expectedTranslations = {
        'en-us': {
          feature: {
            key1: 'English value 1',
            key2: 'English value 2',
          },
        },
        'fr-ca': {},
      };

      beforeEach(() => {
        window.sessionStorage.setItem('i18n:app', appName);
        window.sessionStorage.setItem('i18n:country', countryName);
        window.sessionStorage.setItem('i18n:brand', brandName);
        window.sessionStorage.setItem('i18n:loading_from_redis', loadingFromRedis.toString());
        window.sessionStorage.setItem('i18n:translations', JSON.stringify(translations));
        window.sessionStorage.setItem('i18n:timestamps', JSON.stringify(timestamps));

        window.sessionStorage.removeItem('i18n:non_teladoc_translations');

        fetchMock.mockReturnValue({
          json: jest.fn().mockReturnValue(nonTeladocTranslations),
          ok: true,
        });

        i18n = new I18n(metadata, nonTeladocTranslationsHash);
      });

      it('saves them in the storage and sets hasNonTeladocTranslations to true', () => {
        expect(i18n.app()).toBe(appName);
        expect(i18n.country()).toBe(countryName);
        expect(i18n.brand()).toBe(brandName);
        expect(i18n.loadingFromRedis()).toBe(loadingFromRedis);
        expect(i18n.hasNonTeladocTranslations).toBe(true);

        expect(fetchMock).toHaveBeenCalledTimes(1);
        expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/non_teladoc_translations?id=${nonTeladocTranslationsHash}`, { method: 'GET' });
        expect(i18n.storage.nonTeladocTranslations()).toEqual(nonTeladocTranslations);

        expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
        expect(i18n.storage.translations()).toEqual(expectedTranslations);
        expect(i18n.translations).toEqual(expectedTranslations);
      });
    });
  });

  describe('#translate', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    describe('when passing scope as string', () => {
      it('should call storeDictionary with feature', () => {
        i18n.translate('feature.key');

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });

    describe('when passing scope as array of strings', () => {
      it('should call storeDictionary with feature', () => {
        i18n.translate(['feature', 'key']);

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });
  });

  describe('#pluralize', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    describe('when passing scope as string', () => {
      it('should call storeDictionary with feature', () => {
        i18n.pluralize(1, 'feature.key');

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });

    describe('when passing scope as array of strings', () => {
      it('should call storeDictionary with feature', () => {
        i18n.pluralize(1, ['feature', 'key']);

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });
  });

  describe('#localize', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    describe('when type is number', () => {
      it('should call storeDictionary with number feature', () => {
        i18n.localize('number', 'text to localize');

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('number');
      });
    });

    describe('when type is not number', () => {
      it('should not call storeDictionary', () => {
        i18n.localize('not number', 'text to localize');

        expect(i18n.storeDictionary).not.toHaveBeenCalled();
      });
    });
  });

  describe('#toTime', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    describe('when passing scope as string', () => {
      it('should call storeDictionary with feature', () => {
        i18n.toTime('feature.key', new Date());

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });

    describe('when passing scope as array of strings', () => {
      it('should call storeDictionary with feature', () => {
        i18n.toTime(['feature', 'key'], new Date());

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });
  });

  describe('#numberToCurrency', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    it('should call storeDictionary with number feature', () => {
      i18n.numberToCurrency(1234567890.5);

      expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
      expect(i18n.storeDictionary).toHaveBeenCalledWith('number');
    });
  });

  describe('#numberToPercentage', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    it('should call storeDictionary with number feature', () => {
      i18n.numberToPercentage(100);

      expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
      expect(i18n.storeDictionary).toHaveBeenCalledWith('number');
    });
  });

  describe('#numberToHumanSize', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    it('should call storeDictionary with number feature', () => {
      i18n.numberToHumanSize(1);

      expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
      expect(i18n.storeDictionary).toHaveBeenCalledWith('number');
    });
  });

  describe('#numberToHuman', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    it('should call storeDictionary with number feature', () => {
      i18n.numberToHuman(1);

      expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
      expect(i18n.storeDictionary).toHaveBeenCalledWith('number');
    });
  });

  describe('#strftime', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    it('should call storeDictionary with date and time features', () => {
      i18n.strftime(new Date(), '%a');

      expect(i18n.storeDictionary).toHaveBeenCalledTimes(2);
      expect(i18n.storeDictionary).toHaveBeenCalledWith('date');
      expect(i18n.storeDictionary).toHaveBeenCalledWith('time');
    });
  });

  describe('#toSentence', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    it('should call storeDictionary with support feature', () => {
      i18n.toSentence([]);

      expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
      expect(i18n.storeDictionary).toHaveBeenCalledWith('support');
    });
  });

  describe('#timeAgoInWords', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    describe('when passing scope as string', () => {
      it('should call storeDictionary with feature', () => {
        i18n.timeAgoInWords(new Date(), new Date(), { scope: 'feature.time' });

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });

    describe('when passing scope as array of strings', () => {
      it('should call storeDictionary with feature', () => {
        i18n.timeAgoInWords(new Date(), new Date(), { scope: ['feature', 'time'] });

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });

    describe('when not passing scope', () => {
      it('should call storeDictionary with datetime feature', () => {
        i18n.timeAgoInWords(new Date(), new Date());

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('datetime');
      });
    });
  });

  describe('#get', () => {
    const i18n = mockI18n();

    beforeEach(() => {
      jest.spyOn(i18n, 'storeDictionary');
      jest.mocked(i18n.storeDictionary).mockImplementation(() => {});
    });

    describe('when passing scope as string', () => {
      it('should call storeDictionary with feature', () => {
        i18n.get('feature.key');

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });

    describe('when passing scope as array of strings', () => {
      it('should call storeDictionary with feature', () => {
        i18n.get(['feature', 'key']);

        expect(i18n.storeDictionary).toHaveBeenCalledTimes(1);
        expect(i18n.storeDictionary).toHaveBeenCalledWith('feature');
      });
    });
  });

  describe('#loadingFromRedis', () => {
    const i18n = mockI18n();

    describe('when having the value in storage', () => {
      beforeEach(() => {
        window.sessionStorage.setItem('i18n:loading_from_redis', 'true');
      });

      it('returns the value from the storage', () => {
        expect(i18n.loadingFromRedis()).toBe(true);
      });
    });

    describe('when not having the value in any storage', () => {
      beforeEach(() => {
        window.sessionStorage.removeItem('i18n:loading_from_redis');
        window.localStorage.removeItem('i18n:loading_from_redis');
      });

      it('returns false', () => {
        expect(i18n.loadingFromRedis()).toBe(false);
      });
    });
  });

  describe('#app', () => {
    const i18n = mockI18n();

    describe('when having the value in storage', () => {
      const appName = 'app';

      beforeEach(() => {
        window.sessionStorage.setItem('i18n:app', appName);
      });

      it('returns the value from the storage', () => {
        expect(i18n.app()).toBe(appName);
      });
    });

    describe('when not having the value in any storage', () => {
      beforeEach(() => {
        window.sessionStorage.removeItem('i18n:app');
        window.localStorage.removeItem('i18n:app');
      });

      it('returns empty string', () => {
        expect(i18n.app()).toBe('');
      });
    });
  });

  describe('#country', () => {
    const i18n = mockI18n();

    describe('when having the value in storage', () => {
      const countryName = 'country';

      beforeEach(() => {
        window.sessionStorage.setItem('i18n:country', countryName);
      });

      it('returns the value from the storage', () => {
        expect(i18n.country()).toBe(countryName);
      });
    });

    describe('when not having the value in any storage', () => {
      beforeEach(() => {
        window.sessionStorage.removeItem('i18n:country');
        window.localStorage.removeItem('i18n:country');
      });

      it('returns empty string', () => {
        expect(i18n.country()).toBe('');
      });
    });
  });

  describe('#brand', () => {
    const i18n = mockI18n();

    describe('when having the value in storage', () => {
      const brandName = 'brand';

      beforeEach(() => {
        window.sessionStorage.setItem('i18n:brand', brandName);
      });

      it('returns the value from the storage', () => {
        expect(i18n.brand()).toBe(brandName);
      });
    });

    describe('when not having the value in any storage', () => {
      beforeEach(() => {
        window.sessionStorage.removeItem('i18n:brand');
        window.localStorage.removeItem('i18n:brand');
      });

      it('returns empty string', () => {
        expect(i18n.brand()).toBe('');
      });
    });
  });

  describe('#storeDictionary', () => {
    const translations = {
      'en-us': {
        feature: {
          key1: 'English value 1',
          key2: 'English value 2',
        },
      },
      'es-us': {
        feature: {
          key1: 'Spanish value 1',
        },
      },
    };
    const timestamps = {
      'en-us.feature': oldTimestamp(),
      'es-us.feature': oldTimestamp(),
    };
    const dictionaryEndpointTranslations = {
      'en-us': {
        feature: {
          key1: 'New English value 1',
          key3: 'English value 3',
        },
      },
      'fr-ca': {
        feature: {
          key1: 'French value 1',
        },
      },
    };

    const expectedTimestamps = {
      'en-us.feature': Date.now().toString(),
      'fr-ca.feature': Date.now().toString(),
      'es-us.feature': oldTimestamp(),
    };

    const expectedTranslations = {
      'en-us': {
        feature: {
          key1: 'New English value 1',
          key3: 'English value 3',
        },
      },
      'es-us': {
        feature: {
          key1: 'Spanish value 1',
        },
      },
      'fr-ca': {
        feature: {
          key1: 'French value 1',
        },
      },
    };
    const feature = 'feature';
    let i18n: I18n;

    beforeEach(() => {
      window.sessionStorage.setItem('i18n:timestamps', JSON.stringify(timestamps));
      window.sessionStorage.setItem('i18n:translations', JSON.stringify(translations));

      i18n = mockI18n();

      fetchMock.mockReturnValue({
        json: jest.fn().mockReturnValue(dictionaryEndpointTranslations),
        ok: true,
      });
    });

    it('should store translations and update timestamps', () => {
      i18n.storeDictionary(feature);

      expect(fetchMock).toHaveBeenCalledTimes(1);
      expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

      expect(i18n.storage.translations()).toEqual(expectedTranslations);
      expect(i18n.translations).toEqual(expectedTranslations);
      expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
    });
  });

  describe('#removeTranslationsForTimestampKeys', () => {
    const translations = {
      'en-us': {
        otherFeature: {
          key1: 'English value 1',
        },
        feature: {
          key1: 'English value 1',
          key2: 'English value 2',
        },
      },
      'fr-ca': {
        feature: {
          key1: 'French value 1',
        },
      },
    };

    const timestamps = {
      'en-us.feature': Date.now(),
      'en-us.otherFeature': Date.now(),
      'fr-ca.feature': Date.now(),
    };

    const timestampsToRemove = ['en-us.otherFeature', 'fr-ca.feature', 'es-us.feature'];

    const expectedTranslations = {
      'en-us': {
        feature: {
          key1: 'English value 1',
          key2: 'English value 2',
        },
      },
      'fr-ca': {},
    };

    let i18n: I18n;

    beforeEach(() => {
      window.sessionStorage.setItem('i18n:timestamps', JSON.stringify(timestamps));
      window.sessionStorage.setItem('i18n:translations', JSON.stringify(translations));

      i18n = mockI18n();
    });

    it('removes translations for timestamp keys', () => {
      i18n.removeTranslationsForTimestampKeys(timestampsToRemove);
      expect(i18n.storage.timestamps()).toEqual(timestamps);
      expect(i18n.storage.translations()).toEqual(expectedTranslations);
      expect(i18n.translations).toEqual(expectedTranslations);
    });
  });
});
