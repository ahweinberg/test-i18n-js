import storeDictionary from '../../src/cms/storeDictionary';
import {
  dictionaryEndpointParams, mockI18n, oldTimestamp, setTimestamps, setTranslations,
} from '../../src/setupTests';

const fetchMock = require('sync-fetch');

const i18n = mockI18n();

i18n.locale = 'fr-ca';
const feature = 'feature';

describe('storeDictionary', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('when dictionary is not stored yet', () => {
    describe('when dictionary endpoint returns ok response', () => {
      describe('when there were no translations before', () => {
        const translations = {};
        const timestamps = {};
        const dictionaryEndpointTranslations = {
          'en-us': {
            feature: {
              key1: 'English value 1',
            },
          },
          'fr-ca': {
            feature: {
              key1: 'French value 1',
            },
          },
        };
        const expectedTimestamps = {
          'en-us.feature': Date.now().toString(),
          'fr-ca.feature': Date.now().toString(),
        };

        beforeEach(() => {
          setTranslations(i18n, translations);
          setTimestamps(i18n, timestamps);

          fetchMock.mockReturnValue({
            json: jest.fn().mockReturnValue(dictionaryEndpointTranslations),
            ok: true,
          });
        });

        describe('when non_teladoc_translations endpoint has been called', () => {
          const nonTeladocTranslations = {};

          const expectedTranslations = {
            ...dictionaryEndpointTranslations,
            fr: {},
            en: {},
            'en-ca': {},
          };

          beforeEach(() => {
            i18n.storage.setNonTeladocTranslations(nonTeladocTranslations);
            jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(true);
          });

          it('should store translations and update timestamps', () => {
            storeDictionary(i18n, feature);

            expect(fetchMock).toHaveBeenCalledTimes(1);
            expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

            expect(i18n.storage.translations()).toEqual(expectedTranslations);
            expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
          });
        });

        describe('when non_teladoc_translations endpoint has not been called', () => {
          const expectedTranslations = dictionaryEndpointTranslations;

          beforeEach(() => {
            jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(false);
          });

          it('should store translations and update timestamps', () => {
            storeDictionary(i18n, feature);

            expect(fetchMock).toHaveBeenCalledTimes(1);
            expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

            expect(i18n.storage.translations()).toEqual(expectedTranslations);
            expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
          });
        });
      });

      describe('when there were some translations before', () => {
        describe('when some locales were fetched before', () => {
          const translations = {
            'en-us': {
              feature: {
                key1: 'English value 1',
                key2: 'English value 2',
              },
            },
            'es-us': {
              feature: {
                key1: 'Spanish value 1',
              },
            },
          };
          const timestamps = {
            'en-us.feature': oldTimestamp(),
            'es-us.feature': oldTimestamp(),
          };
          const dictionaryEndpointTranslations = {
            'en-us': {
              feature: {
                key1: 'New English value 1',
                key3: 'English value 3',
              },
            },
            'fr-ca': {
              feature: {
                key1: 'French value 1',
              },
            },
          };

          const expectedTimestamps = {
            'en-us.feature': Date.now().toString(),
            'fr-ca.feature': Date.now().toString(),
            'es-us.feature': oldTimestamp(),
          };

          beforeEach(() => {
            setTranslations(i18n, translations);
            setTimestamps(i18n, timestamps);

            fetchMock.mockReturnValue({
              json: jest.fn().mockReturnValue(dictionaryEndpointTranslations),
              ok: true,
            });
          });

          describe('when non_teladoc_translations endpoint has been called', () => {
            const nonTeladocTranslations = {};

            const expectedTranslations = {
              'en-us': {
                feature: {
                  key1: 'New English value 1',
                  key3: 'English value 3',
                },
              },
              'es-us': {
                feature: {
                  key1: 'Spanish value 1',
                },
              },
              'fr-ca': {
                feature: {
                  key1: 'French value 1',
                },
              },
              fr: {},
              en: {},
              'en-ca': {},
            };

            beforeEach(() => {
              i18n.storage.setNonTeladocTranslations(nonTeladocTranslations);
              jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(true);
            });

            it('should store translations and update timestamps', () => {
              storeDictionary(i18n, feature);

              expect(fetchMock).toHaveBeenCalledTimes(1);
              expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

              expect(i18n.storage.translations()).toEqual(expectedTranslations);
              expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
            });
          });

          describe('when non_teladoc_translations endpoint has not been called', () => {
            const expectedTranslations = {
              'en-us': {
                feature: {
                  key1: 'New English value 1',
                  key3: 'English value 3',
                },
              },
              'es-us': {
                feature: {
                  key1: 'Spanish value 1',
                },
              },
              'fr-ca': {
                feature: {
                  key1: 'French value 1',
                },
              },
            };

            beforeEach(() => {
              jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(false);
            });

            it('should store translations and update timestamps', () => {
              storeDictionary(i18n, feature);

              expect(fetchMock).toHaveBeenCalledTimes(1);
              expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

              expect(i18n.storage.translations()).toEqual(expectedTranslations);
              expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
            });
          });
        });

        describe('when no locales were fetched before', () => {
          const translations = {
            'en-us': {
              otherFeature: {
                key1: 'English value 1',
              },
            },
            'es-us': {
              otherFeature: {
                key1: 'Spanish value 1',
              },
            },
          };
          const timestamps = {
            'en-us.otherFeature': oldTimestamp(),
            'es-us.otherFeature': oldTimestamp(),
          };
          const dictionaryEndpointTranslations = {
            'en-us': {
              feature: {
                key1: 'English value 1',
                key2: 'English value 2',
              },
            },
            'fr-ca': {
              feature: {
                key1: 'French value 1',
              },
            },
          };

          describe('when there are no non teladoc translations for feature', () => {
            const expectedTranslations = {
              'en-us': {
                otherFeature: {
                  key1: 'English value 1',
                },
                feature: {
                  key1: 'English value 1',
                  key2: 'English value 2',
                },
              },
              'es-us': {
                otherFeature: {
                  key1: 'Spanish value 1',
                },
              },
              'fr-ca': {
                feature: {
                  key1: 'French value 1',
                },
              },
            };
            const expectedTimestamps = {
              'en-us.otherFeature': oldTimestamp(),
              'es-us.otherFeature': oldTimestamp(),
              'en-us.feature': Date.now().toString(),
              'fr-ca.feature': Date.now().toString(),
            };

            beforeEach(() => {
              setTranslations(i18n, translations);
              setTimestamps(i18n, timestamps);
              jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(false);

              fetchMock.mockReturnValue({
                json: jest.fn().mockReturnValue(dictionaryEndpointTranslations),
                ok: true,
              });
            });

            it('should store translations and update timestamps', () => {
              storeDictionary(i18n, feature);

              expect(fetchMock).toHaveBeenCalledTimes(1);
              expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

              expect(i18n.storage.translations()).toEqual(expectedTranslations);
              expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
            });
          });

          describe('when there are non teladoc translations for feature', () => {
            const nonTeladocTranslations = {
              'en-us': {
                feature: {
                  key1: 'Non-teladoc English value 1',
                  key3: 'English value 3',
                },
              },
              en: {
                feature: {
                  key1: 'English value 1',
                },
              },
            };

            const expectedTranslations = {
              'en-us': {
                otherFeature: {
                  key1: 'English value 1',
                },
                feature: {
                  key1: 'English value 1',
                  key2: 'English value 2',
                  key3: 'English value 3',
                },
              },
              'es-us': {
                otherFeature: {
                  key1: 'Spanish value 1',
                },
              },
              'fr-ca': {
                feature: {
                  key1: 'French value 1',
                },
              },
              en: {
                feature: {
                  key1: 'English value 1',
                },
              },
              fr: {},
              'en-ca': {},
            };
            const expectedTimestamps = {
              'en-us.otherFeature': oldTimestamp(),
              'es-us.otherFeature': oldTimestamp(),
              'en-us.feature': Date.now().toString(),
              'fr-ca.feature': Date.now().toString(),
            };

            beforeEach(() => {
              setTranslations(i18n, translations);
              setTimestamps(i18n, timestamps);
              i18n.storage.setNonTeladocTranslations(nonTeladocTranslations);
              jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(true);

              fetchMock.mockReturnValue({
                json: jest.fn().mockReturnValue(dictionaryEndpointTranslations),
                ok: true,
              });
            });

            it('should store translations and update timestamps', () => {
              storeDictionary(i18n, feature);

              expect(fetchMock).toHaveBeenCalledTimes(1);
              expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

              expect(i18n.storage.translations()).toEqual(expectedTranslations);
              expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
            });
          });
        });
      });
    });

    describe('when dictionary endpoint does not return ok response', () => {
      beforeAll(() => {
        fetchMock.mockReturnValue({
          ok: false,
        });
      });

      const translations = {
        'en-us': {
          otherFeature: {
            key1: 'English value 1',
          },
        },
        'es-us': {
          otherFeature: {
            key1: 'Spanish value 1',
          },
        },
      };
      const timestamps = {
        'en-us.otherFeature': oldTimestamp(),
        'es-us.otherFeature': oldTimestamp(),
      };

      describe('when there are no non teladoc translations for feature', () => {
        const expectedTranslations = translations;
        const expectedTimestamps = timestamps;

        beforeEach(() => {
          setTranslations(i18n, translations);
          setTimestamps(i18n, timestamps);
          jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(false);
        });

        it('should store no translations and not update timestamps', () => {
          storeDictionary(i18n, feature);

          expect(fetchMock).toHaveBeenCalledTimes(1);
          expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

          expect(i18n.storage.translations()).toEqual(expectedTranslations);
          expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
        });
      });

      describe('when there are non teladoc translations for feature', () => {
        const nonTeladocTranslations = {
          'en-us': {
            feature: {
              key1: 'Non-teladoc English value 1',
              key3: 'English value 3',
            },
          },
          en: {
            feature: {
              key1: 'English value 1',
            },
          },
        };

        const expectedTranslations = {
          'en-us': {
            otherFeature: {
              key1: 'English value 1',
            },
            feature: {
              key1: 'Non-teladoc English value 1',
              key3: 'English value 3',
            },
          },
          'es-us': {
            otherFeature: {
              key1: 'Spanish value 1',
            },
          },
          'fr-ca': {},
          en: {
            feature: {
              key1: 'English value 1',
            },
          },
          fr: {},
          'en-ca': {},
        };
        const expectedTimestamps = timestamps;

        beforeEach(() => {
          setTranslations(i18n, translations);
          setTimestamps(i18n, timestamps);
          i18n.storage.setNonTeladocTranslations(nonTeladocTranslations);
          jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(true);
        });

        it('should store non teladoc translations and not update timestamps', () => {
          storeDictionary(i18n, feature);

          expect(fetchMock).toHaveBeenCalledTimes(1);
          expect(fetchMock).toHaveBeenCalledWith(`teladoc_cms/dictionary?${dictionaryEndpointParams(i18n, feature)}`, { method: 'GET' });

          expect(i18n.storage.translations()).toEqual(expectedTranslations);
          expect(i18n.storage.timestamps()).toEqual(expectedTimestamps);
        });
      });
    });
  });

  describe('when dictionary is already stored', () => {
    const translations = {
      'en-us': {
        feature: {
          key1: 'English value 1',
        },
      },
      'fr-ca': {
        feature: {
          key1: 'Spanish value 1',
        },
      },
    };
    const timestamps = {
      'en-us.feature': oldTimestamp(),
      'fr-ca.feature': oldTimestamp(),
    };

    const nonTeladocTranslations = {
      'en-us': {
        feature: {
          key1: 'Non-teladoc English value 1',
          key3: 'English value 3',
        },
      },
      en: {
        feature: {
          key1: 'English value 1',
        },
      },
    };

    beforeEach(() => {
      setTranslations(i18n, translations);
      setTimestamps(i18n, timestamps);
      i18n.storage.setNonTeladocTranslations(nonTeladocTranslations);
      jest.spyOn(i18n, 'hasNonTeladocTranslations', 'get').mockReturnValue(true);

      fetchMock.mockReturnValue({
        json: jest.fn().mockReturnValue({}),
        ok: true,
      });
    });

    it('should store non teladoc translations and not update timestamps', () => {
      storeDictionary(i18n, feature);

      expect(fetchMock).not.toHaveBeenCalled();

      expect(i18n.storage.translations()).toEqual(translations);
      expect(i18n.storage.timestamps()).toEqual(timestamps);
    });
  });
});
